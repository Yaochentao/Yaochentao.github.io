<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[react初探]]></title>
    <url>%2F2019%2F02%2F25%2Freact%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[使用 create-react-app创建一个react单页应用npx1npx create-react-app my-app npm1npm init react-app my-app yarn1yarn create react-app my-app 工程目录文件简介它将在当前文件夹中创建一个名为my-app的目录。 在该目录中，它将生成初始项目结构并安装依赖项： 1234567891011121314151617my-app├── README.md├── node_modules├── package.json├── .gitignore├── public│ ├── favicon.ico│ ├── index.html│ └── manifest.json└── src ├── App.css ├── App.js ├── App.test.js ├── index.css ├── index.js ├── logo.svg └── serviceWorker.js public/favicon.ico为tab中的favicon图标,在manifest.json中引入 src/App.test.js文件为自动化测试文件 src/index.js为整个程序运行的入口文件 src/App.js是脚手架工具默认创建的组件 /srcserviceWorker.js主要是用于Progressive Web App, 简称 PWA在生产环境中为用户在本地创建一个service worker 来缓存资源到本地，使得在离线状态下也能够正常访问部分页面，提升应用的访问速度 App.test.js是一个自动化的测试文件 启动服务12cd my-appnpm start 打包1npm run build 元素渲染要将React元素渲染到根DOM节点中，我们通过把它们都传递给 ReactDOM.render() 的方法来将其渲染到页面上： 123const element = &lt;h1&gt;Hello, world&lt;/h1&gt;;ReactDOM.render(element, document.getElementById(&apos;root&apos;)); 也可以这么写： 123import TodoList from &apos;./TodoList&apos;ReactDOM.render(&lt;TodoList /&gt;, document.getElementById(&apos;root&apos;)); 组件想下面的Hello.js的代码定义了一个名为Hello的组件 1234567891011121314import React, &#123; Component &#125; from &apos;react&apos;;class Hello extends React.Component &#123; render() &#123; return &lt;h1&gt;&#123;this.state.msg&#125;&lt;/h1&gt;; &#125; constructor(props) &#123; super(props); //当组件的state或者props发生改变的时候，render函数就会重新执行 this.state = &#123; msg: &apos;hello world&apos; &#125; &#125;&#125;export default Hello; 生命周期 常用的react生命周期函数来自react-lifecycle-methods-diagram Constructor(props) 使用 this.state 来初始化 state 给事件处理函数绑定 this ES6 子类的构造函数必须执行一次 super()。React 如果构造函数中要使用 this.props，必须先执行 super(props)。 ##### render()核心函数，必不可少,返回类型包括 React 元素（React elements） 数组（Arrays） 片段（fragments） 插槽（Portals） 字符串或数字（String and numbers） 布尔值或 null（Booleans or null） Ajax请求不能写在render中 会造成死循环。且render中不能使用 setState componentDidMount()组件完成装载（已经插入 DOM 树）时，触发该方法。这个阶段已经获取到真实的 DOM。此时可以： 异步请求 ajax 添加事件绑定（注意在 componentWillUnmount 中取消，以免造成内存泄漏） 123456componentDidMount()&#123; document.body.addEventListener(&apos;click&apos;, this.handleClick); //如果在这里绑定回调函数的this指向，其实就产生了传入匿名函数作为回调一样的问题 &#125;componentWillUnmount()&#123; document.body.removeEventListener(&apos;click&apos;, this.handleClick); //如果在这里绑定回调函数的this指向，其实就产生了传入匿名函数作为回调一样的问题 &#125; 例子来源于SegmentFault 不推荐在这里使用setState函数，它会触发一次额外的渲染，而且是在浏览器刷新屏幕之前执行，用户看不到这个状态。在这里使用setState函数会导致性能问题。 ComponentDidMount()DOM被更新之后调用 可以使用 setState()，会触发 render()，所以要注意判断，避免导致死循环 componentWillUnmount()在组件卸载或者销毁前调用。这个方法主要用来做一些清理工作，例如 : 取消无效timer 取消事件绑定 取消未完成的网络请求 在这里setState()是无效的 shouldComponentUpdate(nextProps, nextState)通常用于性能优化，通过比较this.props与nextProps， 和比较this.state 与 nextState 来返回false阻止组件render PureComponent 的原理就是对 props 和 state 进行浅对比（shallow comparison），来判断是否触发渲染。 后面附上TodoList代码index.js 123456789101112import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;import * as serviceWorker from &apos;./serviceWorker&apos;;import TodoList from &apos;./TodoList&apos;ReactDOM.render(&lt;TodoList /&gt;, document.getElementById(&apos;root&apos;));// If you want your app to work offline and load faster, you can change// unregister() to register() below. Note this comes with some pitfalls.// Learn more about service workers: http://bit.ly/CRA-PWAserviceWorker.unregister(); TodoList.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143import React, &#123; Component, Fragment &#125; from &apos;react&apos;;//ES6解构赋值//等价于 import React from &apos;react&apos;;// const Component = React.Component;// Fragment为占位符 不渲染import TodoItem from &apos;./TodoItem&apos;; //引入TodoItem组件class TodoList extends Component &#123; constructor(props) &#123; super(props); //当组件的state或者props发生改变的时候，render函数就会重新执行 this.state = &#123; inputValue: &apos;&apos;, list: [] &#125; this.handleInputChange = this.handleInputChange.bind(this); //绑定this指向 this.handleBtnClick = this.handleBtnClick.bind(this); &#125; render() &#123; return ( &lt;Fragment&gt; &lt;div&gt; &#123;/* jsx中注释应这么写 */&#125; &#123; //也可以这么注释 &#125; &lt;input className = &apos;input-1&apos; //react中 元素类名class应写为className value=&#123;this.state.inputValue&#125; onChange=&#123;this.handleInputChange.bind(this)&#125; //通过ES6中的bind()函数绑定了this,使handleInputChange中的this指向组件 ref=&#123;(input) =&gt; &#123;this.input = input&#125;&#125; //将this.input指向input,而input就指向ref绑定的dom元素.尽量少用ref这种写法 /&gt; &#123;/* &lt;button onClick=&#123;this.handleBtnClick.bind(this)&#125;&gt;提交&lt;/button&gt; */&#125; &#123;/* 将bind(this)在组件初始化的时候就将this指向绑定好 */&#125; &lt;button onClick=&#123;this.handleBtnClick&#125;&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;ul&gt; &#123; this.state.list.map((item, index) =&gt; &#123; return ( &lt;li key=&#123;index&#125; onClick=&#123;this.handleItemDelete.bind(this, index)&#125; //将item的index传入 // dangerouslySetInnerHTML= &#123;&#123;__html: item&#125;&#125; 用此写法可以不转译 &gt; &#123;item&#125; &lt;/li&gt; ) &#125;) &#125; &lt;/ul&gt; &lt;h1&gt;组件&lt;/h1&gt; &lt;ul&gt; &#123;/* 此处直接引用getTodoItem方法 */&#125; &#123;this.getTodoItem()&#125; &#123;/* &#123; this.state.list.map((item, index) =&gt; &#123; return ( &lt;TodoItem content=&#123;item&#125; index=&#123;index&#125; // 以属性形式向子组件传参 deleteItem = &#123;this.handleItemDelete.bind(this)&#125; //通过属性也可以传递父组件中的方法 //子组件调用的父组件方法中存在this时需改变this指向,指向父组件 /&gt; ) &#125;) &#125; */&#125; &lt;/ul&gt; &lt;/Fragment&gt; ) &#125; //// 将该部分历遍操作的jsx拆分在getTodoItem中 getTodoItem() &#123; return this.state.list.map((item, index) =&gt; &#123; return ( &lt;TodoItem key=&#123;index&#125; //key应放在循环的最外层元素上 content=&#123;item&#125; index=&#123;index&#125; // 以属性形式向子组件传参 deleteItem = &#123;this.handleItemDelete.bind(this)&#125; //通过属性也可以传递父组件中的方法 //子组件调用的父组件方法中存在this时需改变this指向,指向父组件 /&gt; ) &#125;) &#125; handleInputChange(e) &#123; // console.log(e.target.value) //console.log(this) // react中不能通过this.state.inputValue = e.target.value这种形式改变数据 //必须通过this.setState方法 // //e.target为绑定事件的dom节点 // this.setState(&#123; // inputValue: e.target.value // &#125;) // console.log(this.input) const value = e.target.value; this.setState(() =&gt; &#123; return &#123; inputValue: value &#125; &#125;) // ES6中return可简写成以下格式 // this.setState(() =&gt; (&#123; // inputValue: value // &#125;)); &#125; handleBtnClick() &#123; // console.log(...this.state.list) if(this.state.inputValue.length &gt; 0) &#123; //判断输入是否为空 this.setState((prevState) =&gt; &#123; //prevState为之前的状态 相当于this.state return &#123; list: [...prevState.list, prevState.inputValue], //使用es6的展开运算符再拼接成新数组 inputValue: &apos;&apos; &#125; &#125;) &#125; &#125; handleItemDelete(index) &#123; // console.log(index) this.setState((prevState) =&gt; &#123; const list = [...prevState.list]; list.splice(index, 1) return &#123; list: list &#125; //ES6中可简写成return &#123;list&#125; &#125;) // 通过将list暂存在List中 改变List，再通过this.setState将List赋值给list // 实现修改数据 &#125;&#125;export default TodoList; TodoItem.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import React from &apos;react&apos;import axios from &apos;axios&apos;import PropTypes from &apos;prop-types&apos; //引入prop-types进行属性校验class TodoItem extends React.Component &#123; constructor(props) &#123; super(props); this.chlidrenClick = this.chlidrenClick.bind(this); &#125; shouldComponentUpdate(nextProps, nextState) &#123; if(nextProps.content !== this.props.content) &#123; return true; &#125;else &#123; return false; &#125; &#125; //性能优化 ： 判断是否需要重新渲染 render() &#123; //Ajax请求不能写在render中 会造成死循环 console.log(&apos;TodoItem render&apos;) const &#123; content &#125; = this.props; //es6解构赋值 content = this.props.content return ( &lt;div onClick=&#123;this.chlidrenClick&#125;&gt; &#123;/* &#123;this.props.content&#125; */&#125; &#123;content&#125; &lt;/div&gt; //通过this.props.xxx形式访问属性值,接收父组件的数据 ) &#125; componentDidMount() &#123; console.log(&apos;componentDidMount&apos;) //Ajax请求写在componentDidMount中 一般使用axios // console.log(&apos;componentDidMount&apos;) axios.get(&apos;https://api.bzqll.com/music/netease/songList?key=579621905&amp;id=3778678&amp;limit=10&amp;offset=0&apos;) .then((res) =&gt; &#123; console.log(res) &#125;) &#125; chlidrenClick() &#123; console.log(this.props.index); const &#123; deleteItem, index &#125; = this.props; //es6解构赋值 // this.props.deleteItem(this.props.index) deleteItem(index); &#125;&#125;//使用 PropTypes 进行类型检查TodoItem.propTypes = &#123; content: PropTypes.string, deleteItem: PropTypes.func, index: PropTypes.number&#125;//使用defaultProps设置没传值时的属性默认值TodoItem.defaultProps = &#123; content: &apos;&apos;&#125;export default TodoItem; #####]]></content>
  </entry>
  <entry>
    <title><![CDATA[hexo 博文中使用本地图片]]></title>
    <url>%2F2019%2F02%2F25%2Fhexo-%E5%8D%9A%E6%96%87%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[首先安装一个 hexo-asset-image 的npm包 1npm install hexo-asset-image --save 安装完成后，再运行hexo n来生成md博文时，/source/_posts文件夹内会生成跟新建的文件.md文件同名的文件夹。 假设文件目录如下 12345MacGesture2-Publish├── apppicker.jpg├── logo.jpg└── rules.jpgMacGesture2-Publish.md .md文件中只要使用 ![logo](MacGesture2-Publish/logo.jpg)就可以插入图片。]]></content>
  </entry>
  <entry>
    <title><![CDATA[GitHub Pages + Hexo搭建个人博客]]></title>
    <url>%2F2019%2F02%2F15%2FGitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[记一次 github pages + Hexo 搭建个人博客 安装安装前提要使用Hexo，需要在你的系统中支持Nodejs以及Git，如果还没有，那就开始安装吧！ Node环境 Git 安装Hexo1$ npm install -g hexo-cli 安装完成后可查看Hexo版本检查是否安装成功 输入 1$ hexo v 输出 12345678910111213141516hexo-cli: 1.1.0os: Windows_NT 10.0.17134 win32 x64http_parser: 2.8.0node: 8.11.4v8: 6.2.414.54uv: 1.19.1zlib: 1.2.11ares: 1.10.1-DEVmodules: 57nghttp2: 1.32.0napi: 3openssl: 1.0.2picu: 60.1unicode: 10.0cldr: 32.0tz: 2017c 创建博客文件夹并初始化Hexo首先新建一个文件夹，在该文件夹下右键打开Git Bash 输入以下命令 初始化 1hexo init 安装依赖 1npm i Start the server1hexo server 通过浏览器访问http://localhost:4000/，就可以看到blog的页面了。 创建GitHub pages并与博客关联创建GitHub pages登录你的GitHub账号，点击GitHub中的New repositor，创建一个新仓库，每个帐号只能有一个仓库来存放个人主页，而且仓库的名字必须是username/username.github.io，这是特殊的命名约定。你可以通过http://username.github.io 来访问你的个人主页。 创建完成后在setting中将仓库设置为GitHub Pages。 本地Git与GitHub连接右键打开GIt GUI，点击菜单栏Help中的Show SSH Key ，Copy To Clipboard 。打开GitHub个人主页，找到settings中的SSH and GPG keys,点击new SSH key , title 可不填，key填入刚才复制到粘贴板的key，点击Add SSH key。 将本地博客代码提交到github在编辑器中打开上述创建的文件夹，找到最外层的配置文件_config.yml,进入文件内，搜索deploy进行如下更改，repo是我们刚才创建的github的仓库地址 1234deploy: type: git repo: https://github.com/username/username.github.io.git branch: master 通过hexo-deployer-git将代码提交GitHub 1npm install hexo-deployer-git –save 1hexo g 1hexo d 线上查看地址： https://你的仓库名字.github.io/ 配置主题Hexo的主题列表中提供了很多别人创建的主题，我这边选的是NexT。 1git clone https://github.com/iissnan/hexo-theme-next themes/next 在最外层的站点配置文件_config.yml 将theme更改为next 1theme: next 在themes文件夹下的next文件夹下可以找到主题配置文件_config.yml。可以参照NexT官方文档对其进行个性化配置。 新建文章1$ hexo new [layout] &lt;title&gt; source文件夹对应布局文件夹下会生成与title同名的.md文件. 可通过 hexo g 与 hexo d命令更新静态页面。 删除文章先删除本地文件，然后通过生成和部署命令进而将远程仓库中的文件也一并删除。具体来说，以最开始默认形成的helloworld.md这篇文章为例。首先进入到source / _post 文件夹中，找到helloworld.md文件，在本地直接执行删除。然后依次执行hexo g，hexo d，再去主页查看你就会发现你的博客上面helloworld.md这篇文章已经删除了。]]></content>
  </entry>
</search>
