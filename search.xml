<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[记一次vue中获取audio媒体总时长duration遇到的问题]]></title>
    <url>%2F2019%2F03%2F14%2F%E8%AE%B0%E4%B8%80%E6%AC%A1vue%E4%B8%AD%E8%8E%B7%E5%8F%96audio%E5%AA%92%E4%BD%93%E6%80%BB%E6%97%B6%E9%95%BFduration%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[audio获取当前播放时间 在dom挂载完毕后访问currentTime属性获得，通过timeupdate钩子可实时监控 audio 获取媒体总时长 在canplay（浏览器可以开始播放该音视频）钩子函数回调中访问duration属性可获得（注：在dom挂载完直接获取duration会返回NaN） 1&lt;audio @canplay=&quot;getDuration&quot; @timeupdate=&quot;updateTime&quot; ref=&quot;audio&quot; :src=&quot;musicUrl&quot;&gt;&lt;/audio&gt; 123456789methods: &#123; getDuration() &#123; console.log(this.$refs.audio.duration); //此时可以获取到duration this.duration = this.$refs.audio.duration; &#125;, updateTime(e) &#123; this.currentTime = e.target.currentTime; //获取audio当前播放时间 &#125;,&#125; 12345678watch： &#123; currentSong() &#123; //监听正在播放的歌曲改变 this.$nextTick(() =&gt; &#123; this.$refs.audio.play(); console.log(this.$refs.audio.duration); //此时duration为NaN &#125;) &#125;,&#125; audio的方法12345addTextTrack() 为音视频加入一个新的文本轨迹 canPlayType() 检查指定的音视频格式是否得到支持 load() 重新加载音视频标签 play() 播放音视频 pause() 暂停播放当前的音视频 audio的属性123456789101112131415161718192021222324252627282930313233343536audioTracks 返回可用的音轨列表（MultipleTrackList对象） autoplay 媒体加载后自动播放 buffered 返回缓冲部件的时间范围(TimeRanges对象) controller 返回当前的媒体控制器（MediaController对象） controls 显示播控控件 crossOrigin CORS设置 currentSrc 返回当前媒体的URL currentTime 当前播放的时间，单位秒 defaultMuted 缺省是否静音 defaultPlaybackRate 播控的缺省倍速 duration 返回媒体的播放总时长，单位秒 ended 返回当前播放是否结束标志 error 返回当前播放的错误状态 initialTime 返回初始播放的位置 loop 是否循环播放 mediaGroup 当前音视频所属媒体组 (用来链接多个音视频标签) muted 是否静音 networkState 返回当前网络状态 paused 是否暂停 playbackRate 播放的倍速 played 当前播放部件已经播放的时间范围(TimeRanges对象) preload 页面加载时是否同时加载音视频 readyState 返回当前的准备状态 &#123; 0: HAVE_NOTHING 没有准备就绪的状态 1: HAVE_METADATA 关于音频就绪的元数据 2: HAVE_CURRENT_DATA 当前可用，但下一帧不确定 3: HAVE_FUTURE_DATA 当前和下一帧可用 4: HAVE_ENOUGH_DATA 有足够的数据支持播放&#125; seekable 返回当前可跳转部件的时间范围(TimeRanges对象) seeking 返回用户是否做了跳转操作 src 当前音视频源的URL startOffsetTime 返回当前的时间偏移(Date对象) textTracks 返回可用的文本轨迹(TextTrackList对象) videoTracks 返回可用的视频轨迹(VideoTrackList对象) volume 音量值 audio的钩子12345678910111213141516171819202122abort 当音视频加载被异常终止时产生该事件 canplay 当浏览器可以开始播放该音视频时产生该事件 canplaythrough 当浏览器可以开始播放该音视频到结束而无需因缓冲而停止时产生该事件 durationchange 当媒体的总时长改变时产生该事件 emptied 当前播放列表为空时产生该事件 ended 当前播放列表结束时产生该事件 error 当加载媒体发生错误时产生该事件 loadeddata 当加载媒体数据时产生该事件 loadedmetadata 当收到总时长，分辨率和字轨等metadata时产生该事件 loadstart 当开始查找媒体数据时产生该事件 pause 当媒体暂停时产生该事件 play 当媒体播放时产生该事件 playing 当媒体从因缓冲而引起的暂停和停止恢复到播放时产生该事件 progress 当获取到媒体数据时产生该事件 ratechange 当播放倍数改变时产生该事件 seeked 当用户完成跳转时产生该事件 seeking 当用户正执行跳转时操作的时候产生该事件 stalled 当试图获取媒体数据，但数据还不可用时产生该事件 suspend 当获取不到数据时产生该事件 timeupdate 当前播放位置发生改变时产生该事件 volumechange 当前音量发生改变时产生该事件 waiting 当视频因缓冲下一帧而停止时产生该事件]]></content>
  </entry>
  <entry>
    <title><![CDATA[视口单位（ Viewport units )初探]]></title>
    <url>%2F2019%2F03%2F11%2F%E8%A7%86%E5%8F%A3%E5%8D%95%E4%BD%8D%EF%BC%88-Viewport-units-%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[视口单位（ Viewport units )初探起因最近在写的一个仿网易云的webapp中有一个nav组件。其中nav-item需要宽度自适应屏幕的1/4.其中nav-icon需设置圆形。问题在于：宽度不确定，需要设置高度与宽度相同，且icon-font的font-size需随nav-item的宽度变化。首先想到的是css3的calc() 或者设置高为0，让padding撑起高的方案来实现。但是并不能解决font-size需随nav-item的宽度变化。后面了解到了视口单位（ Viewport units ) Viewport 视口在业界，极为推崇的一种理论是 Peter-Paul Koch (江湖人称“PPK大神”)提出的关于视口的解释——在桌面端，视口指的是在桌面端，指的是浏览器的可视区域；而在移动端较为复杂，它涉及到三个视口：分别是 Layout Viewport（布局视口）、 Visual Viewport（视觉视口）、Ideal Viewport。而视口单位中的“视口”，在桌面端，毫无疑问指的就是浏览器的可视区域；但是在移动端，它指的则是三个 Viewport 中的 Layout Viewport 。 Viewport units 视口单位视口单位主要包括以下4个： vw : 1vw 等于视口宽度的1% vh : 1vh 等于视口高度的1% vmin : 选取 vw 和 vh 中最小的那个 vmax : 选取 vw 和 vh 中最大的那个 使用vw设置宽高相同，已经iconfont的font-size自适应。就有了下面的nav组件代码。 123456789101112131415161718&lt;div class=&quot;nav&quot;&gt; &lt;div class=&quot;nav-item&quot;&gt; &lt;i class=&quot;nav-icon iconfont icon-icon--&quot;&gt;&lt;/i&gt; &lt;span class=&quot;nav-text&quot;&gt;私人FM&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;nav-item&quot;&gt; &lt;i class=&quot;nav-icon iconfont icon-calendar_icon&quot;&gt;&lt;/i&gt; &lt;span class=&quot;nav-text&quot;&gt;每日推荐&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;nav-item&quot;&gt; &lt;i class=&quot;nav-icon iconfont icon-icon-&quot;&gt;&lt;/i&gt; &lt;span class=&quot;nav-text&quot;&gt;歌单&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;nav-item&quot;&gt; &lt;i class=&quot;nav-icon iconfont icon-paixingbang&quot;&gt;&lt;/i&gt; &lt;span class=&quot;nav-text&quot;&gt;排行榜&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829.nav &#123; width: 100%; height: 12vh; display: flex; .nav-item &#123; flex: 1; height: 100%; .nav-icon &#123; margin: 1vh 4vw; width: 17vw; height: 17vw; display: inline-block; border-radius: 50%; background: @color-theme; text-align: center; vertical-align: middle; color: @color-text-lm; font-size: 9vw; &#125; .nav-text &#123; display: inline-block; width: 100%; font-size: @font-size-small; color: @color-text-g; text-align: center; &#125; &#125; &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Element UI使用笔记]]></title>
    <url>%2F2019%2F03%2F04%2FElement-UI%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[最近的项目中用到了element ui ，在这里写一些使用笔记 Element UI 自定义主题仅替换主题色使用官网的自定义主题工具，点击切换主题色选定颜色后下载主题，下载得到名为element-#xxxxxx的压缩文件，解压，将文件放入项目目录，引入 12// import &apos;element-ui/lib/theme-chalk/index.css&apos;; 此为element ui默认主题文件 替换成以下样式文件import &apos;element-ui/lib/element-#2E9D81/index.css&apos;; 使用类名修改组件样式可以在引入组件后，使用浏览器检查元素查看需要修改样式的元素类名,修改样式（注意选择器权重，必要时可加!important 中添加修改样式的代码不会生效），例以下可以修改表单label字体颜色。 123.form-item .el-form-item__label &#123; color: #000; &#125; 在项目中改变 SCSS 变量新建一个样式文件，例如 element-variables.scss，写入以下内容： 1234567/* 改变主题色变量 */$--color-primary: teal;/* 改变 icon 字体路径变量，必需 */$--font-path: &apos;~element-ui/lib/theme-chalk/fonts&apos;;@import &quot;~element-ui/packages/theme-chalk/src/index&quot;; 之后，在项目的入口文件中，直接引入以上样式文件即可（无需引入 Element 编译好的 CSS 文件）： 12345import Vue from &apos;vue&apos;import Element from &apos;element-ui&apos;import &apos;./element-variables.scss&apos;Vue.use(Element) 命令行主题工具暂时还未用到~登下次用到了再来填坑 el-scrollbar 滚动条组件项目中需要用到滚动条，但windows浏览器默认的滚动条是很丑的，为了页面美观，可以考虑优化滚动条样式。Element UI官方文档上并没有放出滚动条相关的示例说明，但是实际上是有这么一个组件的，可查看源码，使用时将会出现滚动的内容放到上述标签内就可以了。 12345&lt;div style=&quot;height=200px&quot;&gt; &lt;el-scrollbar style=&quot;height:100%&quot;&gt; &lt;div style=&quot;height: 1000px&quot;&gt;&lt;/div&gt; &lt;/el-scrollbar&gt;&lt;/div&gt; 子元素超出视窗时，组件将会出现滚动条，查看效果的时候，会出现一个横向的滚动条，如果你不想要横向的滚动条，使用下面css属性设置就可以只显示竖向滚动条 123.el-scrollbar__wrap &#123; overflow-x: hidden;&#125; 待续。。。。]]></content>
  </entry>
  <entry>
    <title><![CDATA[react初探]]></title>
    <url>%2F2019%2F02%2F25%2Freact%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[使用 create-react-app创建一个react单页应用npx1npx create-react-app my-app npm1npm init react-app my-app yarn1yarn create react-app my-app 工程目录文件简介它将在当前文件夹中创建一个名为my-app的目录。 在该目录中，它将生成初始项目结构并安装依赖项： 1234567891011121314151617my-app├── README.md├── node_modules├── package.json├── .gitignore├── public│ ├── favicon.ico│ ├── index.html│ └── manifest.json└── src ├── App.css ├── App.js ├── App.test.js ├── index.css ├── index.js ├── logo.svg └── serviceWorker.js public/favicon.ico为tab中的favicon图标,在manifest.json中引入 src/App.test.js文件为自动化测试文件 src/index.js为整个程序运行的入口文件 src/App.js是脚手架工具默认创建的组件 /srcserviceWorker.js主要是用于Progressive Web App, 简称 PWA在生产环境中为用户在本地创建一个service worker 来缓存资源到本地，使得在离线状态下也能够正常访问部分页面，提升应用的访问速度 App.test.js是一个自动化的测试文件 启动服务12cd my-appnpm start 打包1npm run build 元素渲染要将React元素渲染到根DOM节点中，我们通过把它们都传递给 ReactDOM.render() 的方法来将其渲染到页面上： 123const element = &lt;h1&gt;Hello, world&lt;/h1&gt;;ReactDOM.render(element, document.getElementById(&apos;root&apos;)); 也可以这么写： 123import TodoList from &apos;./TodoList&apos;ReactDOM.render(&lt;TodoList /&gt;, document.getElementById(&apos;root&apos;)); 组件想下面的Hello.js的代码定义了一个名为Hello的组件 1234567891011121314import React, &#123; Component &#125; from &apos;react&apos;;class Hello extends React.Component &#123; render() &#123; return &lt;h1&gt;&#123;this.state.msg&#125;&lt;/h1&gt;; &#125; constructor(props) &#123; super(props); //当组件的state或者props发生改变的时候，render函数就会重新执行 this.state = &#123; msg: &apos;hello world&apos; &#125; &#125;&#125;export default Hello; 生命周期 常用的react生命周期函数来自react-lifecycle-methods-diagram Constructor(props) 使用 this.state 来初始化 state 给事件处理函数绑定 this ES6 子类的构造函数必须执行一次 super()。React 如果构造函数中要使用 this.props，必须先执行 super(props)。 ##### render()核心函数，必不可少,返回类型包括 React 元素（React elements） 数组（Arrays） 片段（fragments） 插槽（Portals） 字符串或数字（String and numbers） 布尔值或 null（Booleans or null） Ajax请求不能写在render中 会造成死循环。且render中不能使用 setState componentDidMount()组件完成装载（已经插入 DOM 树）时，触发该方法。这个阶段已经获取到真实的 DOM。此时可以： 异步请求 ajax 添加事件绑定（注意在 componentWillUnmount 中取消，以免造成内存泄漏） 123456componentDidMount()&#123; document.body.addEventListener(&apos;click&apos;, this.handleClick); //如果在这里绑定回调函数的this指向，其实就产生了传入匿名函数作为回调一样的问题 &#125;componentWillUnmount()&#123; document.body.removeEventListener(&apos;click&apos;, this.handleClick); //如果在这里绑定回调函数的this指向，其实就产生了传入匿名函数作为回调一样的问题 &#125; 例子来源于SegmentFault 不推荐在这里使用setState函数，它会触发一次额外的渲染，而且是在浏览器刷新屏幕之前执行，用户看不到这个状态。在这里使用setState函数会导致性能问题。 ComponentDidMount()DOM被更新之后调用 可以使用 setState()，会触发 render()，所以要注意判断，避免导致死循环 componentWillUnmount()在组件卸载或者销毁前调用。这个方法主要用来做一些清理工作，例如 : 取消无效timer 取消事件绑定 取消未完成的网络请求 在这里setState()是无效的 shouldComponentUpdate(nextProps, nextState)通常用于性能优化，通过比较this.props与nextProps， 和比较this.state 与 nextState 来返回false阻止组件render PureComponent 的原理就是对 props 和 state 进行浅对比（shallow comparison），来判断是否触发渲染。 后面附上TodoList代码index.js 123456789101112import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;import * as serviceWorker from &apos;./serviceWorker&apos;;import TodoList from &apos;./TodoList&apos;ReactDOM.render(&lt;TodoList /&gt;, document.getElementById(&apos;root&apos;));// If you want your app to work offline and load faster, you can change// unregister() to register() below. Note this comes with some pitfalls.// Learn more about service workers: http://bit.ly/CRA-PWAserviceWorker.unregister(); TodoList.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143import React, &#123; Component, Fragment &#125; from &apos;react&apos;;//ES6解构赋值//等价于 import React from &apos;react&apos;;// const Component = React.Component;// Fragment为占位符 不渲染import TodoItem from &apos;./TodoItem&apos;; //引入TodoItem组件class TodoList extends Component &#123; constructor(props) &#123; super(props); //当组件的state或者props发生改变的时候，render函数就会重新执行 this.state = &#123; inputValue: &apos;&apos;, list: [] &#125; this.handleInputChange = this.handleInputChange.bind(this); //绑定this指向 this.handleBtnClick = this.handleBtnClick.bind(this); &#125; render() &#123; return ( &lt;Fragment&gt; &lt;div&gt; &#123;/* jsx中注释应这么写 */&#125; &#123; //也可以这么注释 &#125; &lt;input className = &apos;input-1&apos; //react中 元素类名class应写为className value=&#123;this.state.inputValue&#125; onChange=&#123;this.handleInputChange.bind(this)&#125; //通过ES6中的bind()函数绑定了this,使handleInputChange中的this指向组件 ref=&#123;(input) =&gt; &#123;this.input = input&#125;&#125; //将this.input指向input,而input就指向ref绑定的dom元素.尽量少用ref这种写法 /&gt; &#123;/* &lt;button onClick=&#123;this.handleBtnClick.bind(this)&#125;&gt;提交&lt;/button&gt; */&#125; &#123;/* 将bind(this)在组件初始化的时候就将this指向绑定好 */&#125; &lt;button onClick=&#123;this.handleBtnClick&#125;&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;ul&gt; &#123; this.state.list.map((item, index) =&gt; &#123; return ( &lt;li key=&#123;index&#125; onClick=&#123;this.handleItemDelete.bind(this, index)&#125; //将item的index传入 // dangerouslySetInnerHTML= &#123;&#123;__html: item&#125;&#125; 用此写法可以不转译 &gt; &#123;item&#125; &lt;/li&gt; ) &#125;) &#125; &lt;/ul&gt; &lt;h1&gt;组件&lt;/h1&gt; &lt;ul&gt; &#123;/* 此处直接引用getTodoItem方法 */&#125; &#123;this.getTodoItem()&#125; &#123;/* &#123; this.state.list.map((item, index) =&gt; &#123; return ( &lt;TodoItem content=&#123;item&#125; index=&#123;index&#125; // 以属性形式向子组件传参 deleteItem = &#123;this.handleItemDelete.bind(this)&#125; //通过属性也可以传递父组件中的方法 //子组件调用的父组件方法中存在this时需改变this指向,指向父组件 /&gt; ) &#125;) &#125; */&#125; &lt;/ul&gt; &lt;/Fragment&gt; ) &#125; //// 将该部分历遍操作的jsx拆分在getTodoItem中 getTodoItem() &#123; return this.state.list.map((item, index) =&gt; &#123; return ( &lt;TodoItem key=&#123;index&#125; //key应放在循环的最外层元素上 content=&#123;item&#125; index=&#123;index&#125; // 以属性形式向子组件传参 deleteItem = &#123;this.handleItemDelete.bind(this)&#125; //通过属性也可以传递父组件中的方法 //子组件调用的父组件方法中存在this时需改变this指向,指向父组件 /&gt; ) &#125;) &#125; handleInputChange(e) &#123; // console.log(e.target.value) //console.log(this) // react中不能通过this.state.inputValue = e.target.value这种形式改变数据 //必须通过this.setState方法 // //e.target为绑定事件的dom节点 // this.setState(&#123; // inputValue: e.target.value // &#125;) // console.log(this.input) const value = e.target.value; this.setState(() =&gt; &#123; return &#123; inputValue: value &#125; &#125;) // ES6中return可简写成以下格式 // this.setState(() =&gt; (&#123; // inputValue: value // &#125;)); &#125; handleBtnClick() &#123; // console.log(...this.state.list) if(this.state.inputValue.length &gt; 0) &#123; //判断输入是否为空 this.setState((prevState) =&gt; &#123; //prevState为之前的状态 相当于this.state return &#123; list: [...prevState.list, prevState.inputValue], //使用es6的展开运算符再拼接成新数组 inputValue: &apos;&apos; &#125; &#125;) &#125; &#125; handleItemDelete(index) &#123; // console.log(index) this.setState((prevState) =&gt; &#123; const list = [...prevState.list]; list.splice(index, 1) return &#123; list: list &#125; //ES6中可简写成return &#123;list&#125; &#125;) // 通过将list暂存在List中 改变List，再通过this.setState将List赋值给list // 实现修改数据 &#125;&#125;export default TodoList; TodoItem.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import React from &apos;react&apos;import axios from &apos;axios&apos;import PropTypes from &apos;prop-types&apos; //引入prop-types进行属性校验class TodoItem extends React.Component &#123; constructor(props) &#123; super(props); this.chlidrenClick = this.chlidrenClick.bind(this); &#125; shouldComponentUpdate(nextProps, nextState) &#123; if(nextProps.content !== this.props.content) &#123; return true; &#125;else &#123; return false; &#125; &#125; //性能优化 ： 判断是否需要重新渲染 render() &#123; //Ajax请求不能写在render中 会造成死循环 console.log(&apos;TodoItem render&apos;) const &#123; content &#125; = this.props; //es6解构赋值 content = this.props.content return ( &lt;div onClick=&#123;this.chlidrenClick&#125;&gt; &#123;/* &#123;this.props.content&#125; */&#125; &#123;content&#125; &lt;/div&gt; //通过this.props.xxx形式访问属性值,接收父组件的数据 ) &#125; componentDidMount() &#123; console.log(&apos;componentDidMount&apos;) //Ajax请求写在componentDidMount中 一般使用axios // console.log(&apos;componentDidMount&apos;) axios.get(&apos;https://api.bzqll.com/music/netease/songList?key=579621905&amp;id=3778678&amp;limit=10&amp;offset=0&apos;) .then((res) =&gt; &#123; console.log(res) &#125;) &#125; chlidrenClick() &#123; console.log(this.props.index); const &#123; deleteItem, index &#125; = this.props; //es6解构赋值 // this.props.deleteItem(this.props.index) deleteItem(index); &#125;&#125;//使用 PropTypes 进行类型检查TodoItem.propTypes = &#123; content: PropTypes.string, deleteItem: PropTypes.func, index: PropTypes.number&#125;//使用defaultProps设置没传值时的属性默认值TodoItem.defaultProps = &#123; content: &apos;&apos;&#125;export default TodoItem; #####]]></content>
  </entry>
  <entry>
    <title><![CDATA[hexo 博文中使用本地图片]]></title>
    <url>%2F2019%2F02%2F25%2Fhexo-%E5%8D%9A%E6%96%87%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[首先安装一个 hexo-asset-image 的npm包 1npm install hexo-asset-image --save 安装完成后，再运行hexo n来生成md博文时，/source/_posts文件夹内会生成跟新建的文件.md文件同名的文件夹。 假设文件目录如下 12345MacGesture2-Publish├── apppicker.jpg├── logo.jpg└── rules.jpgMacGesture2-Publish.md .md文件中只要使用 ![logo](MacGesture2-Publish/logo.jpg)就可以插入图片。]]></content>
  </entry>
  <entry>
    <title><![CDATA[GitHub Pages + Hexo搭建个人博客]]></title>
    <url>%2F2019%2F02%2F15%2FGitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[记一次 github pages + Hexo 搭建个人博客 安装安装前提要使用Hexo，需要在你的系统中支持Nodejs以及Git，如果还没有，那就开始安装吧！ Node环境 Git 安装Hexo1$ npm install -g hexo-cli 安装完成后可查看Hexo版本检查是否安装成功 输入 1$ hexo v 输出 12345678910111213141516hexo-cli: 1.1.0os: Windows_NT 10.0.17134 win32 x64http_parser: 2.8.0node: 8.11.4v8: 6.2.414.54uv: 1.19.1zlib: 1.2.11ares: 1.10.1-DEVmodules: 57nghttp2: 1.32.0napi: 3openssl: 1.0.2picu: 60.1unicode: 10.0cldr: 32.0tz: 2017c 创建博客文件夹并初始化Hexo首先新建一个文件夹，在该文件夹下右键打开Git Bash 输入以下命令 初始化 1hexo init 安装依赖 1npm i Start the server1hexo server 通过浏览器访问http://localhost:4000/，就可以看到blog的页面了。 创建GitHub pages并与博客关联创建GitHub pages登录你的GitHub账号，点击GitHub中的New repositor，创建一个新仓库，每个帐号只能有一个仓库来存放个人主页，而且仓库的名字必须是username/username.github.io，这是特殊的命名约定。你可以通过http://username.github.io 来访问你的个人主页。 创建完成后在setting中将仓库设置为GitHub Pages。 本地Git与GitHub连接右键打开GIt GUI，点击菜单栏Help中的Show SSH Key ，Copy To Clipboard 。打开GitHub个人主页，找到settings中的SSH and GPG keys,点击new SSH key , title 可不填，key填入刚才复制到粘贴板的key，点击Add SSH key。 将本地博客代码提交到github在编辑器中打开上述创建的文件夹，找到最外层的配置文件_config.yml,进入文件内，搜索deploy进行如下更改，repo是我们刚才创建的github的仓库地址 1234deploy: type: git repo: https://github.com/username/username.github.io.git branch: master 通过hexo-deployer-git将代码提交GitHub 1npm install hexo-deployer-git –save 1hexo g 1hexo d 线上查看地址： https://你的仓库名字.github.io/ 配置主题Hexo的主题列表中提供了很多别人创建的主题，我这边选的是NexT。 1git clone https://github.com/iissnan/hexo-theme-next themes/next 在最外层的站点配置文件_config.yml 将theme更改为next 1theme: next 在themes文件夹下的next文件夹下可以找到主题配置文件_config.yml。可以参照NexT官方文档对其进行个性化配置。 新建文章1$ hexo new [layout] &lt;title&gt; source文件夹对应布局文件夹下会生成与title同名的.md文件. 可通过 hexo g 与 hexo d命令更新静态页面。 删除文章先删除本地文件，然后通过生成和部署命令进而将远程仓库中的文件也一并删除。具体来说，以最开始默认形成的helloworld.md这篇文章为例。首先进入到source / _post 文件夹中，找到helloworld.md文件，在本地直接执行删除。然后依次执行hexo g，hexo d，再去主页查看你就会发现你的博客上面helloworld.md这篇文章已经删除了。]]></content>
  </entry>
</search>
